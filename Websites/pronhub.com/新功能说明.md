# 新功能说明

## 功能概述

本次更新添加了智能跳过机制、采集日志记录、静默工作模式等功能，提升了程序的稳定性和用户体验。

## 新增功能

### 1. 智能跳过机制

**功能描述**: 自动跳过已经采集完成的视频，避免重复处理

**实现原理**:
- 检查每个视频文件夹中的 `collection_log.txt` 文件
- 如果日志文件存在且包含"采集状态: 成功"，则跳过该视频
- 如果日志文件不存在或状态为失败，则重新处理

**配置选项**:
```python
SCRAPER_CONFIG = {
    'skip_existing': True,  # 是否跳过已存在的ID
}
```

**优势**:
- 节省时间和网络资源
- 支持断点续传
- 避免重复下载

### 2. 采集日志记录

**功能描述**: 为每个视频创建详细的采集日志，记录采集过程和结果

**日志内容**:
```
采集日志
================

采集时间: 2024-01-15 14:30:25
视频ID: 471425945
ViewKey: 686b24c4659e9
视频标题: 一早就被肥美的蜜桃臀用各种姿势主动榨干 💀...
视频链接: https://cn.pornhub.com/view_video.php?viewkey=686b24c4659e9

采集信息:
- 缩略图: 已下载
- 预览视频: 已下载
- 发布时间: 1个月前
- 分类数量: 11
- m3u8地址: 已获取

采集状态: 成功
```

**日志状态**:
- **成功**: 所有文件下载成功，HTML页面创建完成
- **失败**: 部分文件下载失败或处理过程中出错
- **处理中**: 正在处理该视频

**优势**:
- 详细记录采集过程
- 便于问题排查
- 支持采集状态检查

### 3. 静默工作模式

**功能描述**: 隐藏子进程运行信息，只显示错误信息，过滤空错误和超时

**配置选项**:
```python
SCRAPER_CONFIG = {
    'show_worker_info': False,  # 是否显示工作线程信息
}

DEBUG = {
    'verbose': False,  # 是否显示详细信息
}
```

**显示内容**:
- ✅ 成功信息: 隐藏（除非启用显示）
- ❌ 错误信息: 过滤后显示（忽略空错误、超时等）
- 📊 统计信息: 始终显示
- 🔧 线程状态: 隐藏（除非启用显示）

**错误过滤规则**:
- 忽略包含 "timeout" 的错误
- 忽略包含 "empty" 的错误  
- 忽略包含 "none" 的错误
- 只显示真正的网络错误和程序错误

**优势**:
- 减少输出噪音
- 突出重要信息
- 提升用户体验
- 避免频繁的状态更新

### 4. Selenium自动化

**功能描述**: 使用Selenium WebDriver进行页面抓取，支持JavaScript渲染和反检测

**实现原理**:
- 自动下载并配置ChromeDriver
- 使用Chrome浏览器进行页面访问
- 支持JavaScript渲染的动态内容
- 内置反检测机制
- 自动回退到requests模式

**配置选项**:
```python
SELENIUM_CONFIG = {
    'use_selenium': True,  # 是否使用Selenium
    'headless': False,     # 无头模式
    'disable_images': True,  # 禁用图片加载
    'disable_javascript': False,  # 禁用JavaScript
    'window_size': '1920,1080',  # 窗口大小
    'page_load_timeout': 30,  # 页面加载超时
    'implicit_wait': 10,   # 隐式等待
    'explicit_wait': 10,   # 显式等待
}
```

**优势**:
- 支持JavaScript渲染的动态内容
- 更好的反检测能力
- 可以处理复杂的页面交互
- 自动配置ChromeDriver
- 智能回退机制

### 5. 自动年龄验证

**功能描述**: 自动处理"我已满十八岁"验证弹窗，无需手动点击

**实现原理**:
- 检测年龄验证弹窗
- 多种选择器策略查找按钮
- 自动点击验证按钮
- JavaScript备选点击方案
- 智能错误处理

**按钮代码**:
```html
<button class="gtm-event-age-verification js-closeAgeModal buttonOver18 orangeButton" data-event="age_verification" data-label="over18_enter">我年满 18 岁 - 输入</button>
```

**选择器策略**:
```python
age_button_selectors = [
    "button.gtm-event-age-verification.js-closeAgeModal.buttonOver18.orangeButton",
    "button[data-event='age_verification']",
    "button[data-label='over18_enter']",
    ".orangeButton",
    "button:contains('我年满 18 岁')",
    "button:contains('18')"
]
```

**优势**:
- 自动处理年龄验证
- 多种选择器确保成功率
- JavaScript备选方案
- 智能错误处理
- 详细调试信息

### 5. 边解析边下载

**功能描述**: 解析一个页面后立即处理该页面视频，无需等待所有页面解析完成

**实现原理**:
- 解析一个页面
- 立即处理该页面的所有视频
- 同时开始下载任务
- 继续解析下一页
- 边解析边下载，提高效率

**优势**:
- 内存占用更小（只存储当前页面数据）
- 响应速度更快（立即开始处理）
- 用户体验更好（实时反馈）
- 支持大规模数据采集

### 5. 下载线程数增加

**功能描述**: 将下载线程数从10个增加到30个

**配置选项**:
```python
SCRAPER_CONFIG = {
    'download_threads': 30,  # 下载线程数（增加到30个）
}
```

**优势**:
- 提高下载效率
- 减少等待时间
- 更好的并发处理

## 技术实现

### 1. 跳过机制实现

```python
def is_video_completed(self, viewkey):
    """检查视频是否已完成采集"""
    try:
        log_file = os.path.join(folder_path, 'collection_log.txt')
        if not os.path.exists(log_file):
            return False
        
        with open(log_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        return '采集状态: 成功' in content
    except Exception as e:
        return False
```

### 2. 日志记录实现

```python
def create_collection_log(self, video_data, folder_path, success=True, error_msg=''):
    """创建采集日志"""
    current_time = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    log_content = f"""采集日志
================

采集时间: {current_time}
视频ID: {video_data.get('video_id', 'N/A')}
ViewKey: {video_data.get('viewkey', 'N/A')}
视频标题: {video_data.get('title', 'N/A')}
视频链接: {video_data.get('video_url', 'N/A')}

采集信息:
- 缩略图: {'已下载' if video_data.get('thumbnail_url') else '无'}
- 预览视频: {'已下载' if video_data.get('preview_url') else '无'}
- 发布时间: {video_data.get('publish_time', 'N/A')}
- 分类数量: {len(video_data.get('categories', []))}
- m3u8地址: {'已获取' if video_data.get('best_m3u8_url') else '无'}

采集状态: {'成功' if success else '失败'}
"""
    
    with open(log_file, 'w', encoding='utf-8') as f:
        f.write(log_content)
```

### 3. 静默模式实现

```python
def download_worker(self, worker_id):
    """下载工作线程"""
    while True:
        try:
            task = self.download_queue.get(timeout=1)
            if task is None:
                break
            
            url, filepath, task_type = task
            
            # 只在显示工作线程信息时输出
            if SCRAPER_CONFIG.get('show_worker_info', False):
                print(f"线程 {worker_id}: 开始下载 {task_type}")
            
            success = self.download_file(url, filepath)
            
            with self.download_lock:
                self.download_results[filepath] = success
                if success and SCRAPER_CONFIG.get('show_worker_info', False):
                    print(f"线程 {worker_id}: ✓ {task_type} 下载成功")
                elif not success:
                    print(f"线程 {worker_id}: ✗ {task_type} 下载失败")
                    
        except Exception as e:
            # 只显示真正的错误，忽略空错误和超时
            if str(e) and not any(empty_error in str(e).lower() for empty_error in ['timeout', 'empty', 'none']):
                print(f"线程 {worker_id} 错误: {e}")
```

**错误过滤实现**:
```python
# 错误过滤逻辑
if str(e) and not any(empty_error in str(e).lower() for empty_error in ['timeout', 'empty', 'none']):
    print(f"线程 {worker_id} 错误: {e}")
```

**静默模式控制**:
```python
# 启动线程时
if DEBUG['verbose']:
    print(f"启动 {num_threads} 个下载线程")

# 停止线程时  
if DEBUG['verbose']:
    print("所有下载线程已停止")
```

### 4. Selenium实现

```python
def init_selenium_driver(self):
    """初始化Selenium WebDriver"""
    chrome_options = Options()
    chrome_options.add_argument('--no-sandbox')
    chrome_options.add_argument('--disable-dev-shm-usage')
    chrome_options.add_argument('--disable-blink-features=AutomationControlled')
    chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
    
    # 自动下载并配置ChromeDriver
    service = Service(ChromeDriverManager().install())
    self.driver = webdriver.Chrome(service=service, options=chrome_options)
    
    # 执行反检测脚本
    self.driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
```

**Selenium vs Requests对比**:

| 特性 | Selenium | Requests |
|------|----------|----------|
| JavaScript支持 | ✓ 完全支持 | ✗ 不支持 |
| 动态内容 | ✓ 可以处理 | ✗ 无法处理 |
| 反检测能力 | ✓ 强 | ✗ 弱 |
| 性能 | 较慢 | 较快 |
| 资源占用 | 较高 | 较低 |

### 5. 年龄验证实现

```python
def handle_age_verification(self):
    """处理年龄验证弹窗"""
    age_button_selectors = [
        "button.gtm-event-age-verification.js-closeAgeModal.buttonOver18.orangeButton",
        "button[data-event='age_verification']",
        "button[data-label='over18_enter']",
        ".orangeButton"
    ]
    
    for selector in age_button_selectors:
        try:
            age_button = WebDriverWait(self.driver, 3).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, selector))
            )
            if age_button and age_button.is_displayed():
                age_button.click()
                time.sleep(2)
                return True
        except TimeoutException:
            continue
```

**年龄验证流程**:
1. 访问目标页面
2. 等待页面加载完成
3. 检查年龄验证弹窗
4. 尝试多种选择器查找按钮
5. 点击验证按钮
6. 等待页面更新
7. 继续正常抓取流程

### 6. 边解析边下载实现

```python
def scrape_and_download_pages(self, start_page=1, end_page=None, auto_detect_last=True):
    """边解析边下载页面"""
    while current_page <= end_page:
        # 解析当前页面
        videos = self.parse_video_list(html_content)
        
        # 立即处理当前页面的视频
        for video_data in videos:
            if self.process_video(video_data):
                success_count += 1
        
        # 继续解析下一页
        current_page += 1
```

**传统方式 vs 边解析边下载**:

| 特性 | 传统方式 | 边解析边下载 |
|------|----------|--------------|
| 内存占用 | 高（存储所有数据） | 低（只存储当前页面） |
| 响应速度 | 慢（等待所有解析） | 快（立即开始处理） |
| 用户体验 | 差（长时间无反馈） | 好（实时反馈） |
| 扩展性 | 差（内存限制） | 好（支持大规模） |

## 使用方法

### 1. 启用跳过功能（默认启用）

```python
# 在config.py中设置
SCRAPER_CONFIG = {
    'skip_existing': True,  # 跳过已存在的ID
}
```

### 2. 启用静默模式（默认启用）

```python
# 在config.py中设置
SCRAPER_CONFIG = {
    'show_worker_info': False,  # 隐藏工作线程信息
}

DEBUG = {
    'verbose': False,  # 隐藏详细信息
}
```

### 3. 启用详细模式（调试时使用）

```python
# 在config.py中设置
SCRAPER_CONFIG = {
    'show_worker_info': True,  # 显示工作线程信息
}

DEBUG = {
    'verbose': True,  # 显示详细信息
}
```

### 3. 查看采集日志

```bash
# 查看特定视频的采集日志
cat data/686b24c4659e9/collection_log.txt
```

### 4. 手动检查采集状态

```python
from app import PornhubScraper

scraper = PornhubScraper()
is_completed = scraper.is_video_completed('686b24c4659e9')
print(f"视频是否已完成: {is_completed}")
```

## 测试脚本

### 1. 跳过功能测试

```bash
python test_skip_existing.py
```

### 2. 完整功能测试

```bash
python app.py
```

## 注意事项

1. **日志文件**: 每个视频文件夹都会创建 `collection_log.txt` 文件
2. **跳过逻辑**: 只有状态为"成功"的视频才会被跳过
3. **错误处理**: 所有错误信息都会正常显示，不受静默模式影响
4. **性能影响**: 30个下载线程可能会增加系统负载，请根据实际情况调整

## 兼容性

- ✅ Python 3.7+
- ✅ Windows/Linux/macOS
- ✅ 与现有功能完全兼容
- ✅ 向后兼容旧版本数据

## 更新日志

### v2.0.0 (2024-01-15)
- ✨ 新增智能跳过机制
- ✨ 新增采集日志记录
- ✨ 新增静默工作模式
- ⚡ 下载线程数增加到30个
- 🔧 优化错误处理和日志记录
- 📝 完善文档和测试脚本 